diff --git a/src/lib/ares_process.c b/src/lib/ares_process.c
index 605e5f8..f07d7b3 100644
--- a/src/lib/ares_process.c
+++ b/src/lib/ares_process.c
@@ -579,6 +579,12 @@ static void process_answer(ares_channel channel, unsigned char *abuf,
   struct query *query;
   struct list_node* list_head;
   struct list_node* list_node;
+  int rr_type, rr_class, rr_len, status;
+  const unsigned char *aptr;
+  unsigned int ancount, i;
+  char *hostname = NULL, *rr_name = NULL;
+  long len;
+  int acount = 0;
 
   /* If there's no room in the answer for a header, we can't do much
    * with it. */
@@ -590,6 +596,9 @@ static void process_answer(ares_channel channel, unsigned char *abuf,
   tc = DNS_HEADER_TC(abuf);
   rcode = DNS_HEADER_RCODE(abuf);
 
+  /* Fetch the answer count from the header. */
+  ancount = DNS_HEADER_ANCOUNT(abuf);
+
   /* Find the query corresponding to this packet. The queries are
    * hashed/bucketed by query id, so this lookup should be quick.  Note that
    * both the query id and the questions must be the same; when the query id
@@ -654,12 +663,78 @@ static void process_answer(ares_channel channel, unsigned char *abuf,
   if (alen > packetsz && !tcp)
       alen = packetsz;
 
+  /* Parse the RR name. */
+  aptr = abuf + HFIXEDSZ;
+  status = ares_expand_name(aptr, abuf, alen, &hostname, &len);
+  if (status != ARES_SUCCESS)
+    return;
+
+  /* Make sure there is enough data after the RR name for the fixed
+   * part of the RR.
+   */
+  if (aptr + RRFIXEDSZ > abuf + alen)
+  {
+    ares_free_string(hostname);
+    return;
+  }
+  aptr += len + QFIXEDSZ;
+
+  /* Examine each answer resource record (RR) in turn. */
+  for (i = 0; i < ancount; i++)
+  {
+    /* Decode the RR up to the data field. */
+    status = ares_expand_name(aptr, abuf, alen, &rr_name, &len);
+    if (status != ARES_SUCCESS)
+      {
+        break;
+      }
+    aptr += len;
+    if (aptr + RRFIXEDSZ > abuf + alen)
+      {
+        status = ARES_EBADRESP;
+        break;
+      }
+    rr_type = DNS_RR_TYPE(aptr);
+    rr_class = DNS_RR_CLASS(aptr);
+    rr_len = DNS_RR_LEN(aptr);
+    aptr += RRFIXEDSZ;
+    if (aptr + rr_len > abuf + alen)
+      {
+        status = ARES_EBADRESP;
+        break;
+      }
+
+    /* Check if we are really looking at a CAA record */
+    if ((rr_class == C_IN || rr_class == C_CHAOS) && (rr_type == T_A || rr_type == T_AAAA))
+      {
+        acount++;
+      }
+
+    /* Propagate any failures */
+    if (status != ARES_SUCCESS)
+      {
+        break;
+      }
+
+    /* Don't lose memory in the next iteration */
+    ares_free(rr_name);
+    rr_name = NULL;
+
+    /* Move on to the next record */
+    aptr += rr_len;
+  }
+
+  if (hostname)
+    ares_free(hostname);
+  if (rr_name)
+    ares_free(rr_name);
+
   /* If we aren't passing through all error packets, discard packets
    * with SERVFAIL, NOTIMP, or REFUSED response codes.
    */
   if (!(channel->flags & ARES_FLAG_NOCHECKRESP))
     {
-      if (rcode == SERVFAIL || rcode == NOTIMP || rcode == REFUSED)
+      if (rcode == SERVFAIL || rcode == NOTIMP || rcode == REFUSED || acount == 0)
         {
           skip_server(channel, query, whichserver);
           if (query->server == whichserver)
