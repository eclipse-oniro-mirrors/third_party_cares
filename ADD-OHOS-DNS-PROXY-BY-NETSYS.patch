diff --git a/.clang-format b/.clang-format
new file mode 100644
index 0000000..175dd67
--- /dev/null
+++ b/.clang-format
@@ -0,0 +1,173 @@
+# Copyright (C) 2022 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+Language: Cpp
+# BasedOnStyle:  LLVM
+# 访问说明符(public、private等)的偏移
+AccessModifierOffset: -4
+# 开括号(开圆括号、开尖括号、开方括号)后的对齐
+AlignAfterOpenBracket: Align
+# 连续赋值时，等号对齐
+AlignConsecutiveAssignments: false
+# 连续赋值时，变量名对齐
+AlignConsecutiveDeclarations: false
+# 左对齐逃脱换行(使用反斜杠换行)的反斜杠
+AlignEscapedNewlinesLeft: true
+# 水平对齐二元和三元表达式的操作数
+AlignOperands: true
+# 对齐连续的尾随的注释
+AlignTrailingComments: true
+# 允许函数声明的所有参数在放在下一行
+AllowAllParametersOfDeclarationOnNextLine: false
+# 允许短的块放在同一行
+AllowShortBlocksOnASingleLine: false
+# 允许短的case标签放在同一行
+AllowShortCaseLabelsOnASingleLine: false
+# 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All
+AllowShortFunctionsOnASingleLine: Empty
+# 允许短的if语句保持在同一行
+AllowShortIfStatementsOnASingleLine: false
+# 允许短的循环保持在同一行
+AllowShortLoopsOnASingleLine: false
+# 总是在定义返回类型后换行(deprecated)
+AlwaysBreakAfterDefinitionReturnType: None
+# 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数),
+#   AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)
+AlwaysBreakAfterReturnType: None
+# 总是在多行string字面量前换行
+AlwaysBreakBeforeMultilineStrings: true
+# 总是在template声明后换行
+AlwaysBreakTemplateDeclarations: false
+# false表示函数实参要么都在同一行，要么都各自一行
+BinPackArguments: true
+# false表示所有形参要么都在同一行，要么都各自一行
+BinPackParameters: true
+# 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效
+BraceWrapping:
+  AfterClass: false
+  AfterControlStatement: false
+  AfterEnum: false
+  AfterFunction: true
+  AfterNamespace: false
+  AfterObjCDeclaration: false
+  AfterStruct: false
+  AfterUnion: false
+  BeforeCatch: false
+  BeforeElse: false
+  IndentBraces: false
+# 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)
+BreakBeforeBinaryOperators: None
+# 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似),
+#   Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似),
+#   Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom
+#   注：这里认为语句块也属于函数
+BreakBeforeBraces: Custom
+# 在三元运算符前换行
+BreakBeforeTernaryOperators: true
+# 在构造函数的初始化列表的逗号前换行
+BreakConstructorInitializersBeforeComma: false
+# 每行字符的限制，0表示没有限制
+ColumnLimit: 120
+# 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变
+CommentPragmas: "^ IWYU pragma:"
+# 构造函数的初始化列表要么都在同一行，要么都各自一行
+ConstructorInitializerAllOnOneLineOrOnePerLine: true
+# 构造函数的初始化列表的缩进宽度
+ConstructorInitializerIndentWidth: 4
+# 延续的行的缩进宽度
+ContinuationIndentWidth: 4
+# 去除C++11的列表初始化的大括号{后和}前的空格
+Cpp11BracedListStyle: true
+# 继承最常用的指针和引用的对齐方式
+DerivePointerAlignment: false
+# 关闭格式化
+DisableFormat: false
+# 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)
+ExperimentalAutoDetectBinPacking: false
+# 需要被解读为foreach循环而不是函数调用的宏
+ForEachMacros: [ foreach, Q_FOREACH, BOOST_FOREACH ]
+# 对#include进行排序，匹配了某正则表达式的#include拥有对应的优先级，匹配不到的则默认优先级为INT_MAX(优先级越小排序越靠前)，
+# 可以定义负数优先级从而保证某些#include永远在最前面
+IncludeCategories:
+  - Regex: '^"(llvm|llvm-c|clang|clang-c)/'
+    Priority: 2
+  - Regex: '^(<|"(gtest|isl|json)/)'
+    Priority: 3
+  - Regex: ".*"
+    Priority: 1
+# 缩进case标签
+IndentCaseLabels: true
+# 缩进宽度
+IndentWidth: 4
+# 函数返回类型换行时，缩进函数声明或函数定义的函数名
+IndentWrappedFunctionNames: true
+# 保留在块开始处的空行
+KeepEmptyLinesAtTheStartOfBlocks: true
+# 开始一个块的宏的正则表达式
+MacroBlockBegin: ""
+# 结束一个块的宏的正则表达式
+MacroBlockEnd: ""
+# 连续空行的最大数量
+MaxEmptyLinesToKeep: 1
+# 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), All
+NamespaceIndentation: None
+# 使用ObjC块时缩进宽度
+ObjCBlockIndentWidth: 4
+# 在ObjC的@property后添加一个空格
+ObjCSpaceAfterProperty: false
+# 在ObjC的protocol列表前添加一个空格
+ObjCSpaceBeforeProtocolList: true
+# 在call(后对函数调用换行的penalty
+PenaltyBreakBeforeFirstCallParameter: 19
+# 在一个注释中引入换行的penalty
+PenaltyBreakComment: 300
+# 第一次在<<前换行的penalty
+PenaltyBreakFirstLessLess: 120
+# 在一个字符串字面量中引入换行的penalty
+PenaltyBreakString: 1000
+# 对于每个在行字符数限制之外的字符的penalty
+PenaltyExcessCharacter: 1000000
+# 将函数的返回类型放到它自己的行的penalty
+PenaltyReturnTypeOnItsOwnLine: 120
+# 指针和引用的对齐: Left, Right, Middle
+PointerAlignment: Right
+# 允许重新排版注释
+ReflowComments: true
+# 允许排序#include
+#SortIncludes: Never
+# 在C风格类型转换后添加空格
+SpaceAfterCStyleCast: false
+# 在赋值运算符之前添加空格
+SpaceBeforeAssignmentOperators: true
+# 开圆括号之前添加一个空格: Never, ControlStatements, Always
+SpaceBeforeParens: ControlStatements
+# 在空的圆括号中添加空格
+SpaceInEmptyParentheses: false
+# 在尾随的评论前添加的空格数(只适用于//)
+SpacesBeforeTrailingComments: 1
+# 在尖括号的<后和>前添加空格
+SpacesInAngles: false
+# 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格
+SpacesInContainerLiterals: true
+# 在C风格类型转换的括号中添加空格
+SpacesInCStyleCastParentheses: false
+# 在圆括号的(后和)前添加空格
+SpacesInParentheses: false
+# 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响
+SpacesInSquareBrackets: false
+# 标准: Cpp03, Cpp11, Auto
+Standard: Cpp11
+# tab宽度
+TabWidth: 4
+# 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, Always
+UseTab: Never
\ No newline at end of file
diff --git a/.vscode/launch.json b/.vscode/launch.json
new file mode 100644
index 0000000..f980ab9
--- /dev/null
+++ b/.vscode/launch.json
@@ -0,0 +1,7 @@
+{
+    // 使用 IntelliSense 了解相关属性。 
+    // 悬停以查看现有属性的描述。
+    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387
+    "version": "0.2.0",
+    "configurations": []
+}
\ No newline at end of file
diff --git a/src/lib/ares_getaddrinfo.c b/src/lib/ares_getaddrinfo.c
index 0a0225a..563940f 100644
--- a/src/lib/ares_getaddrinfo.c
+++ b/src/lib/ares_getaddrinfo.c
@@ -578,6 +578,14 @@ void ares_getaddrinfo(ares_channel channel,
                       const struct ares_addrinfo_hints* hints,
                       ares_addrinfo_callback callback, void* arg)
 {
+#if OHOS_DNS_PROXY_BY_NETSYS
+  struct addrinfo hint;
+  struct addrinfo *res;
+  memset(&hint, 0, sizeof(hint));
+  hint.ai_family = hints->ai_family;
+  hint.ai_socktype = hints->ai_socktype;
+  getaddrinfo(name, service, &hint, &res);
+#endif
   struct host_query *hquery;
   unsigned short port = 0;
   int family;
diff --git a/src/lib/ares_init.c b/src/lib/ares_init.c
index e8902c6..b78c401 100644
--- a/src/lib/ares_init.c
+++ b/src/lib/ares_init.c
@@ -58,6 +58,65 @@
 #undef WIN32  /* Redefined in MingW/MSVC headers */
 #endif
 
+
+#if OHOS_DNS_PROXY_BY_NETSYS
+#include <dlfcn.h>
+#include <stdio.h>
+
+#if DNS_CONFIG_DEBUG
+#ifndef DNS_CONFIG_PRINT
+#define DNS_CONFIG_PRINT(fmt, ...) printf("DNS " fmt "\n", ##__VA_ARGS__)
+#endif
+#else
+#define DNS_CONFIG_PRINT(fmt, ...)
+#endif
+
+#define DNS_SO_PATH "libnetsys_client.z.so"
+#define OHOS_GET_CONFIG_FUNC_NAME "NetSysGetResolvConf"
+#define MAX_SERVER_NUM 4
+#define MAX_SERVER_LENGTH 50
+#define EAI_NONAME     -2
+
+struct resolv_config {
+  int32_t error;
+  int32_t timeout_ms;
+  uint32_t retry_count;
+  char nameservers[MAX_SERVER_NUM][MAX_SERVER_LENGTH + 1];
+};
+
+typedef int32_t (*GetConfig)(uint16_t netId, struct resolv_config *config);
+
+static void *open_dns_lib(void)
+{
+  static void *lib = NULL;
+  if (lib != NULL) {
+    return lib;
+  }
+  lib = dlopen(DNS_SO_PATH, RTLD_LAZY);
+  if (lib == NULL) {
+    DNS_CONFIG_PRINT("%s: dlopen %s failed: %s",
+      __func__, DNS_SO_PATH, dlerror());
+    return NULL;
+  }
+  return lib;
+}
+
+static void *load_from_dns_lib(const char *symbol)
+{
+  void *lib_handle = open_dns_lib();
+  if (lib_handle == NULL) {
+    return NULL;
+  }
+
+  void *sym_addr = dlsym(lib_handle, symbol);
+  if (sym_addr == NULL) {
+    DNS_CONFIG_PRINT("%s: loading symbol %s with dlsym failed: %s",
+      __func__, symbol, dlerror());
+}
+  return sym_addr;
+}
+#endif
+
 static int init_by_options(ares_channel channel,
                            const struct ares_options *options,
                            int optmask);
@@ -1720,6 +1779,35 @@ static int init_by_resolv_conf(ares_channel channel)
       resolvconf_path = PATH_RESOLV_CONF;
     }
 
+#if OHOS_DNS_PROXY_BY_NETSYS
+    int netid = 0;
+    GetConfig func = NULL;
+    *(void **) &func = load_from_dns_lib(OHOS_GET_CONFIG_FUNC_NAME);
+    if (!func) {
+      DNS_CONFIG_PRINT("%s: loading %s failed, use %s as a fallback",
+        __func__, OHOS_GET_CONFIG_FUNC_NAME, DNS_RESOLV_CONF_PATH);
+      goto etc_resolv_conf;
+    }
+    struct resolv_config config = {0};
+    int ret = func(netid, &config);
+    if (ret < 0) {
+      DNS_CONFIG_PRINT("__get_resolv_conf OHOS_GET_CONFIG_FUNC_NAME err %d\n", ret);
+      return EAI_NONAME;
+    }
+
+    for (int i = 0; i < MAX_SERVER_NUM; ++i) {
+      if (config.nameservers[i] == NULL || config.nameservers[i][0] == 0) {
+        continue;
+      }
+      status = config_nameserver(&servers, &nservers, config.nameservers[i]);
+    }
+
+    if (status == ARES_SUCCESS && nservers > 0) {
+      goto get_conf_ok;
+    }
+
+etc_resolv_conf:
+#endif
     fp = fopen(resolvconf_path, "r");
     if (fp) {
       while ((status = ares__read_line(fp, &line, &linesize)) == ARES_SUCCESS)
@@ -1866,7 +1954,9 @@ static int init_by_resolv_conf(ares_channel channel)
         ares_free(sortlist);
       return status;
     }
-
+#if OHOS_DNS_PROXY_BY_NETSYS
+get_conf_ok:
+#endif
   /* If we got any name server entries, fill them in. */
   if (servers)
     {
